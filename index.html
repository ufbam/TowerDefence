<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GeoTD — Single‑File Tower Defense (No Assets)</title>
  <style>
    :root {
      --bg: #0f1222;
      --panel: #12162b;
      --panel-2: #0b0e1c;
      --text: #f1f5f9;
      --muted: #94a3b8;
      --accent: #5eead4;
      --danger: #f472b6;
      --good: #a7f3d0;
      --warn: #fbbf24;
      --grid: #1f2548;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 65% 40%, #101533 0%, var(--bg) 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      user-select: none;
      overflow: hidden;
    }
    .wrap {
      display: grid;
      grid-template-columns: 320px 1fr;
      grid-template-rows: auto 1fr;
      gap: 0;
      height: 100%;
    }
    header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.0));
      border-bottom: 1px solid #202646;
    }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.5px; font-weight: 700; }
    header .meta { display: flex; gap: 16px; align-items: center; font-size: 14px; }
    header .pill { padding: 6px 10px; border-radius: 999px; background: #12183a; border: 1px solid #1e2655; }

    aside {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      border-right: 1px solid #202646;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* single column toolbar so it never overlays gameplay */
    .toolbar { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .btn {
      display: flex; align-items: center; gap: 10px;
      padding: 8px; border: 1px solid #243065; border-radius: 12px;
      background: #0f1537; color: var(--text);
      cursor: pointer; transition: transform .06s ease, background .2s ease, border .2s ease;
    }
    .btn:hover { transform: translateY(-2px); background: #121a48; }
    .btn.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(94,234,212,.15) inset; }
    .btn .cost { margin-left: auto; color: var(--warn); font-weight: 700; }
    .btn canvas { border-radius: 8px; background: #0b0f2a; border: 1px solid #1b2452; }

    .panel { padding: 10px; border: 1px solid #1f274e; border-radius: 12px; background: #0b0f2a; }
    .label { font-size: 12px; color: var(--muted); }
    .stat { font-size: 30px; font-weight: 900; letter-spacing: .5px; }

    .actions { display: flex; gap: 8px; }
    .actions button, .mini button { flex: 1; padding: 10px 12px; border-radius: 10px; border: 1px solid #22306a; background: #0e1440; color: var(--text); cursor: pointer; }
    .actions button:hover, .mini button:hover { background: #141d5c; }

    .mini { display:flex; gap:8px; align-items:center; }
    .seg { display:flex; gap:6px; }
    .seg button { padding: 8px 10px; border-radius: 8px; border:1px solid #22306a; background:#0f1537; cursor:pointer; }
    .seg button.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(94,234,212,.15) inset; }

    .help { font-size: 12px; color: var(--muted); line-height: 1.5; }

    .canvas-wrap { position: relative; }
    canvas#game { display: block; width: 100%; height: calc(100vh - 56px); background:
      linear-gradient(90deg, transparent 49%, rgba(255,255,255,.025) 50%, transparent 51%) 0 0/40px 40px,
      linear-gradient(0deg, transparent 49%, rgba(255,255,255,.02) 50%, transparent 51%) 0 0/40px 40px,
      radial-gradient(1000px 800px at 60% 35%, rgba(94,234,212,.07), transparent 60%)
      ; }
    .toast { position: absolute; top: 14px; left: 14px; background: rgba(18,24,64,.9); padding: 8px 10px; font-size: 13px; border: 1px solid #22306a; border-radius: 8px; opacity: 0; transform: translateY(-6px); transition: all .25s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }

    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; border:1px solid #2a3872; background:#0d1340; }
    .red { color:#fecdd3; }
    .green { color:#bbf7d0; }
    .gold { color:#fde68a; }

    /* tower panel */
    .tpanel { position:absolute; min-width: 180px; background: rgba(12,16,48,.96); border:1px solid #23306a; border-radius: 10px; padding:10px; box-shadow: 0 8px 30px rgba(0,0,0,.3); pointer-events: auto; }
    .tpanel h4 { margin:0 0 6px; font-size:14px; }
    .tpanel .row { display:flex; justify-content:space-between; font-size:12px; color:var(--muted); margin:4px 0; }
    .tpanel .row strong { color: var(--text); }
    .tpanel .btns { display:flex; gap:6px; margin-top:6px; }
    .tpanel .btns button { flex:1; padding:6px 8px; border-radius:8px; border:1px solid #22306a; background:#0f1537; color:var(--text); cursor:pointer; }
    .tpanel .btns button:hover { background:#141d5c; }
    .hidden { display:none; }

    @media (max-width: 980px) {
      .wrap { grid-template-columns: 1fr; grid-template-rows: auto auto auto 1fr; }
      aside { grid-row: 2; }
      canvas#game { height: calc(100vh - 280px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>GeoTD — Pure Canvas Tower Defense</h1>
      <div class="meta">
        <div class="pill">No images • No libs • Single file</div>
        <div class="pill">GitHub Pages ready</div>
        <div class="pill" id="version">v1.2.1</div>
      </div>
    </header>

    <aside>
      <div class="panel">
        <div class="label">Stats</div>
        <div style="display:flex; gap:18px; margin-top:6px; flex-wrap:wrap; align-items: baseline;">
          <div>
            <div class="label">Cash</div>
            <div class="stat" id="ui-cash">$0</div>
          </div>
          <div>
            <div class="label">Lives</div>
            <div class="stat" id="ui-lives">20</div>
          </div>
          <div>
            <div class="label">Waves</div>
            <div class="stat" id="ui-wave">0</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="label" style="margin-bottom:8px;">Build — click a tower, then click near (but not on) the path</div>
        <div class="toolbar" id="toolbar"></div>
      </div>

      <div class="panel actions">
        <button id="startWave" title="Waves are stackable">Start Wave</button>
        <button id="sellMode">Sell (S)</button>
      </div>

      <div class="panel mini">
        <div class="label" style="min-width:54px">Speed</div>
        <div class="seg">
          <button id="spd1" class="active">x1</button>
          <button id="spd2">x2</button>
          <button id="spd3">x3</button>
        </div>
        <button id="nextMap" style="margin-left:auto">Next Map</button>
      </div>

      <div class="panel mini">
        <button id="saveBtn">Save</button>
        <button id="loadBtn">Load</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div class="panel help">
        <div><span class="badge gold">Tip</span> Waves are <b>stackable</b>. Start another any time to increase the chaos. Place towers outside the faint path corridor. Hold <b>R</b> to rotate before placing. Press <b>S</b> to toggle sell mode. Click a tower to <b>upgrade</b> it (or press <b>U</b>).</div>
        <div style="margin-top:6px;"><span class="badge">Keys</span> 1–5 select towers • <b>Space</b> start wave • <b>P</b> pause • <b>U</b> upgrade selected</div>
      </div>
    </aside>

    <div class="canvas-wrap">
      <canvas id="game"></canvas>
      <div class="toast" id="toast"></div>
      <div id="towerPanel" class="tpanel hidden"></div>
    </div>
  </div>

  <script>
/**
 * GeoTD — single‑file, no‑asset tower defense for GitHub Pages
 * Drop this file in a repo as `index.html` and enable GitHub Pages (root).
 *
 * v1.2.0 additions (non‑breaking):
 * - Speed controls x1/x2/x3
 * - Multiple maps (Next Map)
 * - Save/Load/Reset via localStorage
 * - Tower upgrades with on‑canvas panel + (U) hotkey (levels 1‑3)
 */

(() => {
  const GAME_VERSION = '1.2.1';
  const SAVE_KEY = 'geotd-save-v1';

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const ui = {
    cash: document.getElementById('ui-cash'),
    lives: document.getElementById('ui-lives'),
    wave: document.getElementById('ui-wave'),
    toolbar: document.getElementById('toolbar'),
    startWave: document.getElementById('startWave'),
    sellMode: document.getElementById('sellMode'),
    toast: document.getElementById('toast'),
    towerPanel: document.getElementById('towerPanel'),
    speedBtns: [document.getElementById('spd1'), document.getElementById('spd2'), document.getElementById('spd3')],
    nextMap: document.getElementById('nextMap'),
    saveBtn: document.getElementById('saveBtn'),
    loadBtn: document.getElementById('loadBtn'),
    resetBtn: document.getElementById('resetBtn'),
  };
  document.getElementById('version').textContent = 'v'+GAME_VERSION;

  // --- Colors ---
  const COLORS = {
    enemy: ['#60a5fa','#34d399','#f472b6','#f59e0b','#a78bfa','#fb7185'],
    path: '#22306a',
    startHole: '#0ea5e9',
    endHole: '#f43f5e',
    hpGood: '#22c55e',
    hpMid: '#fbbf24',
    hpLow: '#ef4444',
    range: 'rgba(59,130,246,0.12)'
  };

  // --- Game State (declare BEFORE resize to avoid early-reference bugs) ---
  const state = {
    cash: 150,
    lives: 20,
    wavesStarted: 0,
    playing: true,
    building: null, // tower type key
    buildRotation: 0,
    sellMode: false,
    speed: 1,
    enemies: [],
    towers: [],
    projectiles: [],
    beams: [],   // laser beams {x1,y1,x2,y2,ttl,color,width}
    zaps: [],    // lightning polylines [{pts:[{x,y}..],ttl,color}]
    path: [],
    pathWidth: 38,
    spawners: [], // multiple concurrent waves
    mouse: {x:0,y:0,down:false},
    selectedTower: null,
    mapIndex: 0,
  };

  // --- Maps defined BEFORE resize/generatePath ---
  const Maps = [
    { name: 'Snake', build() { const w = canvas.clientWidth, h = canvas.clientHeight, margin = 80, bands = 6; const pts=[]; for (let i=0;i<=bands;i++){ const y=margin + (h - margin*2) * (i/bands); const x = i%2===0?margin:w-margin; const wob = (i===0||i===bands)?0:(i%2===0?1:-1)*40; pts.push({x:x+wob,y}); } return pts; } },
    { name: 'Diagonal Zig', build(){ const w=canvas.clientWidth, h=canvas.clientHeight, margin=70; const pts=[], steps=7; for(let i=0;i<=steps;i++){ const t=i/steps; const x=margin+(w-2*margin)*t; const y=margin+(h-2*margin)*((i%2)?0.2:0.8); pts.push({x,y}); } return pts; } },
    { name: 'Wide S‑Curve', build(){ const w=canvas.clientWidth, h=canvas.clientHeight, m=70, midY=h/2; const pts=[], bends=5; for(let i=0;i<=bends;i++){ const t=i/bends; const x=m+(w-2*m)*t; const y= midY + Math.sin(t*Math.PI*2 - Math.PI/2)*(h*0.28); pts.push({x,y}); } return pts; } },
  ];

  function generatePath(){ state.path = Maps[state.mapIndex].build(); }

  // --- Responsive canvas ---
  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // Only rebuild path after state & maps exist
    generatePath();
  }
  const ro = new ResizeObserver(resize); ro.observe(canvas);
  resize();

  // --- Helpers ---
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function pointSegDist(px, py, ax, ay, bx, by) { const vx = bx - ax, vy = by - ay; const wx = px - ax, wy = py - ay; const c1 = vx*wx + vy*wy; if (c1 <= 0) return Math.hypot(px-ax, py-ay); const c2 = vx*vx + vy*vy; if (c2 <= c1) return Math.hypot(px-bx, py-by); const t = c1 / c2; const projx = ax + t*vx, projy = ay + t*vy; return Math.hypot(px - projx, py - projy); }
  function distToPath(x,y){ let best = Infinity; for (let i=0;i<state.path.length-1;i++){ const a=state.path[i], b=state.path[i+1]; best = Math.min(best, pointSegDist(x,y,a.x,a.y,b.x,b.y)); } return best; }

  // --- Enemies ---
  const ENEMY_BASE_SPEED = 0.7;
  const ENEMY_TYPES = [
    { name:'Circle',  shape:'circle',  hp: 36, speed: 1.00, reward: 8 },
    { name:'Hex',     shape:'hex',     hp: 48, speed: 0.95, reward: 10 },
    { name:'Star',    shape:'star',    hp: 28, speed: 1.20, reward: 7 },
    { name:'Diamond', shape:'diamond', hp: 60, speed: 0.85, reward: 12 },
  ];
  function makeEnemyForWave(waveNum) { const type = ENEMY_TYPES[(Math.random()*ENEMY_TYPES.length)|0]; const hp = Math.round(type.hp * (1 + (waveNum-1)*0.35)); const speed = ENEMY_BASE_SPEED * type.speed * (1 + (waveNum-1)*0.05); const color = COLORS.enemy[(Math.random()*COLORS.enemy.length)|0]; return { type, color, x: state.path[0].x, y: state.path[0].y, seg: 0, t: 0, hp, maxHp: hp, slow: 0, slowTimer: 0, alive: true }; }
  function moveEnemy(e) { const speedFactor = e.slow>0 ? (1 - e.slow) : 1; let spd = speedFactor * (e.type.speed) * ENEMY_BASE_SPEED * 1.4; let remaining = spd; while (remaining > 0 && e.seg < state.path.length-1) { const a = state.path[e.seg], b = state.path[e.seg+1]; const ax=a.x, ay=a.y, bx=b.x, by=b.y; const vx = bx-ax, vy=by-ay; const L = Math.hypot(vx,vy) || 1; const step = Math.min(remaining, (1 - e.t) * L); const t2 = e.t + step / L; e.x = lerp(ax,bx,t2); e.y = lerp(ay,by,t2); e.t = t2; if (e.t >= 1 - 1e-6) { e.seg++; e.t = 0; } remaining -= step; } if (e.slowTimer>0) { e.slowTimer--; if (e.slowTimer<=0){ e.slow=0; } } if (e.seg >= state.path.length-1) { e.alive = false; state.lives = Math.max(0, state.lives-1); showToast('-1 life', true); } }

  function drawEnemy(e) { ctx.save(); ctx.translate(e.x, e.y); ctx.shadowColor = e.color; ctx.shadowBlur = 8; ctx.fillStyle = e.color; ctx.strokeStyle = 'rgba(0,0,0,.4)'; ctx.lineWidth = 2; const size = 12; switch (e.type.shape) { case 'circle':  ctx.beginPath(); ctx.arc(0,0,size,0,Math.PI*2); ctx.fill(); ctx.stroke(); break; case 'hex': polygon(6, size); ctx.fill(); ctx.stroke(); break; case 'star': star(5, size, size*0.5); ctx.fill(); ctx.stroke(); break; case 'diamond': ctx.beginPath(); ctx.moveTo(0,-size); ctx.lineTo(size,0); ctx.lineTo(0,size); ctx.lineTo(-size,0); ctx.closePath(); ctx.fill(); ctx.stroke(); break; } ctx.shadowBlur = 0; const hpRatio = clamp(e.hp / e.maxHp, 0, 1); ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.strokeStyle = hpRatio>0.66?COLORS.hpGood:hpRatio>0.33?COLORS.hpMid:COLORS.hpLow; ctx.beginPath(); ctx.moveTo(-14, -18); ctx.lineTo(-14 + 28*hpRatio, -18); ctx.stroke(); ctx.restore(); }
  function polygon(sides, r){ ctx.beginPath(); for (let i=0;i<sides;i++){ const a = (i/sides)*Math.PI*2 - Math.PI/2; const x = Math.cos(a)*r, y = Math.sin(a)*r; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); }
  function star(points, r1, r2){ ctx.beginPath(); for (let i=0;i<points*2;i++){ const r = i%2===0 ? r1 : r2; const a = (i/(points*2))*Math.PI*2 - Math.PI/2; const x = Math.cos(a)*r, y = Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); }

  // --- Towers ---
  const TOWERS = [
    { key:'dart',   name:'Dart',   cost: 60,  dmg: 10, range: 120, cd: 22, bulletSpeed: 5, color:'#60a5fa', baseShape:'hex',    mode:'projectile' },
    { key:'cannon', name:'Cannon', cost: 90,  dmg: 22, range: 140, cd: 36, bulletSpeed: 4, color:'#fbbf24', baseShape:'square', mode:'projectile', splash: 30 },
    { key:'sniper', name:'Laser',  cost: 130, dmg: 46, range: 280, cd: 90,                              color:'#a78bfa', baseShape:'triangle', mode:'beam', beamWidth: 3 },
    { key:'frost',  name:'Field',  cost: 110, dmg: 0,  range: 150, cd:  0,                              color:'#67e8f9', baseShape:'circle',  mode:'aura', slow: 0.45 },
    { key:'tri',    name:'Tesla',  cost: 150, dmg: 14, range: 160, cd: 42,                              color:'#34d399', baseShape:'oct',     mode:'chain', chain: 3, chainRange: 110 },
  ];
  const TowerByKey = Object.fromEntries(TOWERS.map(t=>[t.key,t]));
  const UPGRADE_COST = { dart:[70,120], cannon:[90,150], sniper:[130,190], frost:[80,130], tri:[120,180] };
  const UPGRADE_BONUS = {
    dart:   [{dmg:+6, range:+20, cd:-4}, {dmg:+10, range:+30, cd:-4}],
    cannon: [{dmg:+10, range:+20, cd:-4, splash:+12}, {dmg:+14, range:+30, cd:-4, splash:+18}],
    sniper: [{dmg:+26, range:+40, cd:-10, beamWidth:+1}, {dmg:+34, range:+60, cd:-10, beamWidth:+1}],
    frost:  [{range:+30, slow:+0.05}, {range:+40, slow:+0.05}],
    tri:    [{dmg:+8, range:+20, cd:-4, chain:+1}, {dmg:+10, range:+30, cd:-4, chain:+1, chainRange:+20}],
  };
  function getStats(tower){ const base = TowerByKey[tower.key]; const out = { ...base }; const lvl = (tower.level||1) - 1; for (let i=0;i<lvl;i++){ const b = (UPGRADE_BONUS[tower.key]||[])[i]; if (!b) continue; for (const k in b){ out[k] = (out[k]||0) + b[k]; } } out.cd = Math.max(6, Math.round(out.cd||0)); return out; }

  function drawTower(t){ const base = TowerByKey[t.key]; const stats = getStats(t); const {x,y} = t; ctx.save(); ctx.translate(x,y); ctx.fillStyle = '#0e143a'; ctx.strokeStyle = '#1f2b66'; ctx.lineWidth = 2; switch(base.baseShape){ case 'square': ctx.beginPath(); ctx.roundRect(-16,-16,32,32,6); ctx.fill(); ctx.stroke(); break; case 'triangle': ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(18,16); ctx.lineTo(-18,16); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case 'circle': ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill(); ctx.stroke(); break; case 'oct': polygon(8,16); ctx.fill(); ctx.stroke(); break; default: polygon(6,16); ctx.fill(); ctx.stroke(); }
    if (state.selectedTower===t){ ctx.strokeStyle = '#5eead4aa'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.stroke(); }
    ctx.rotate(t.rot||0); ctx.fillStyle = base.color; ctx.strokeStyle = '#0b0f2a'; ctx.lineWidth = 2; if (base.mode==='projectile'){ ctx.beginPath(); ctx.roundRect(-5,-8, 26,16, 6); ctx.fill(); ctx.stroke(); } else if (base.mode==='beam'){ ctx.beginPath(); ctx.roundRect(-6,-7, 28,14, 8); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(6,0,6,10,0,0,Math.PI*2); ctx.stroke(); } else if (base.mode==='aura'){ ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); ctx.stroke(); } else if (base.mode==='chain'){ ctx.beginPath(); ctx.roundRect(-7,-7, 22,14, 6); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(10,0,4,0,Math.PI*2); ctx.stroke(); } ctx.restore(); if (base.mode==='aura'){ const pulse = 0.06 * (performance.now()%1000); ctx.save(); ctx.globalAlpha = 0.16 + 0.04*Math.sin(pulse); ctx.fillStyle = 'rgba(103,232,249,0.18)'; ctx.strokeStyle = '#1f2b66'; ctx.lineWidth = 1.2; ctx.beginPath(); ctx.arc(x,y, stats.range, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); } }

  function canPlace(x,y){ return distToPath(x,y) > state.pathWidth + 18; }
  function spawnProjectile(tower, target, stats){ const angle = Math.atan2(target.y - tower.y, target.x - tower.x); const p = { x:tower.x, y:tower.y, vx: Math.cos(angle)*stats.bulletSpeed, vy: Math.sin(angle)*stats.bulletSpeed, dmg: stats.dmg, color: TowerByKey[tower.key].color, splash: stats.splash||0, alive:true }; state.projectiles.push(p); }
  function addBeam(x1,y1,x2,y2,color,width){ state.beams.push({x1,y1,x2,y2,color,width: width||3, ttl: 8}); }
  function addZapPath(x1,y1,x2,y2,color){ const segs = 6; const pts=[{x:x1,y:y1}]; for(let i=1;i<segs;i++){ const t=i/segs; const bx=lerp(x1,x2,t), by=lerp(y1,y2,t); const nx=by - y1, ny=-(bx - x1); const len = 6; const off = (Math.random()*2-1)*len; const mag = Math.hypot(nx,ny)||1; pts.push({x: bx + nx/mag*off, y: by + ny/mag*off}); } pts.push({x:x2,y:y2}); state.zaps.push({pts, color, ttl: 8}); }

  // build toolbar UI
  function makeTowerButton(t){ const el = document.createElement('div'); el.className = 'btn'; const icon = document.createElement('canvas'); icon.width=64; icon.height=48; const c = icon.getContext('2d'); c.translate(24,24); c.fillStyle = '#0e143a'; c.strokeStyle = '#23306a'; c.lineWidth=2; c.beginPath(); if (t.baseShape==='square'){ c.roundRect(-14,-14,28,28,6);} else if (t.baseShape==='triangle'){ c.moveTo(0,-16); c.lineTo(16,12); c.lineTo(-16,12); c.closePath(); } else if (t.baseShape==='circle'){ c.arc(0,0,14,0,Math.PI*2);} else if (t.baseShape==='oct'){ const pts=8; c.moveTo(12,0); for(let i=1;i<pts;i++){ const a=i/pts*Math.PI*2; c.lineTo(Math.cos(a)*12, Math.sin(a)*12);} c.closePath(); } else { for(let i=0;i<6;i++){ const a=i/6*Math.PI*2 - Math.PI/2; const x=Math.cos(a)*14, y=Math.sin(a)*14; if(i===0)c.moveTo(x,y); else c.lineTo(x,y);} c.closePath(); } c.fill(); c.stroke(); c.save(); c.rotate(0.4); c.fillStyle = t.color; c.strokeStyle="#0b0f2a"; c.lineWidth=2; c.beginPath(); if (t.mode==='projectile') c.roundRect(-4,-6, 22,12, 5); else if (t.mode==='beam')  c.roundRect(-5,-6, 24,12, 6); else if (t.mode==='aura')  c.arc(0,0,8,0,Math.PI*2); else if (t.mode==='chain') { c.roundRect(-5,-6, 20,12, 5); } c.fill(); c.stroke(); c.restore(); const label = document.createElement('div'); label.textContent = t.name; const cost = document.createElement('div'); cost.textContent = "$"+t.cost; cost.className='cost'; el.append(icon, label, cost); el.onclick = ()=>{ state.building = t.key; state.sellMode=false; state.selectedTower=null; refreshToolbar(); }; el.dataset.key = t.key; return el; }
  function refreshToolbar(){ [...ui.toolbar.children].forEach(btn=>btn.classList.toggle('selected', btn.dataset.key===state.building)); ui.sellMode.classList.toggle('selected', state.sellMode); }
  function showToast(msg, danger=false){ const t = ui.toast; t.textContent = msg; t.classList.add('show'); t.style.borderColor = danger?'#5a1e3a':'#22306a'; clearTimeout(showToast._tid); showToast._tid = setTimeout(()=>t.classList.remove('show'), 900); }
  TOWERS.forEach(t => ui.toolbar.appendChild(makeTowerButton(t))); refreshToolbar();

  // Controls
  canvas.addEventListener('mousemove', e=>{ const r = canvas.getBoundingClientRect(); state.mouse.x = (e.clientX - r.left); state.mouse.y = (e.clientY - r.top); });
  canvas.addEventListener('mousedown', e=>{ state.mouse.down = true; });
  window.addEventListener('mouseup', e=>{ state.mouse.down = false; });
  canvas.addEventListener('click', e=>{ const x = state.mouse.x, y = state.mouse.y; if (state.sellMode) { let hit = findTowerAt(x,y); if (hit){ state.cash += Math.floor(hit.cost * 0.7); state.towers = state.towers.filter(t => t!==hit); state.selectedTower=null; showToast(`Sold +$${Math.floor(hit.cost*0.7)}`); updateUI(); } return; } if (state.building) { const base = TowerByKey[state.building]; if (state.cash < base.cost) { showToast('Not enough cash', true); return; } if (!canPlace(x,y)) { showToast('Too close to path', true); return; } state.towers.push({ key: base.key, x, y, cd: 0, rot: state.buildRotation, cost: base.cost, level:1 }); state.cash -= base.cost; state.selectedTower = state.towers[state.towers.length-1]; updateUI(); return; } const t = findTowerAt(x,y); state.selectedTower = t || null; updateTowerPanel(); });
  function findTowerAt(x,y){ return state.towers.find(t => Math.hypot(t.x-x, t.y-y) < 18); }
  window.addEventListener('keydown', e=>{ const k = e.key.toLowerCase(); if (k==='p') state.playing = !state.playing; if (k===' '){ startWave(); e.preventDefault(); } if (k==='r'){ state.buildRotation += Math.PI/12; } if (k==='s'){ state.sellMode = !state.sellMode; state.selectedTower=null; refreshToolbar(); } if (k==='u'){ upgradeSelected(); } if (k>='1' && k<='5'){ const idx = +k-1; state.building = TOWERS[idx].key; state.sellMode=false; state.selectedTower=null; refreshToolbar(); } if (k==='escape'){ state.selectedTower=null; updateTowerPanel(); } });
  window.addEventListener('keydown', e=>{ if(e.key==='r' || e.key==='R') e.preventDefault(); }, {passive:false});

  // Speed controls
  ui.speedBtns.forEach((b,i)=> b.onclick = ()=>{ state.speed = i+1; ui.speedBtns.forEach(x=>x.classList.remove('active')); b.classList.add('active'); });
  // Map cycling
  ui.nextMap.onclick = ()=>{ let refund = 0; for (const t of state.towers) refund += Math.floor(t.cost*0.8); if (refund>0){ state.cash += refund; showToast(`Map changed • Refunded $${refund}`); } state.towers.length=0; state.enemies.length=0; state.projectiles.length=0; state.beams.length=0; state.zaps.length=0; state.spawners.length=0; state.selectedTower=null; state.mapIndex = (state.mapIndex+1)%Maps.length; generatePath(); updateUI(); };
  // Save/Load/Reset
  ui.saveBtn.onclick = saveGame; ui.loadBtn.onclick = loadGame; ui.resetBtn.onclick = resetGame;
  ui.startWave.onclick = startWave; ui.sellMode.onclick = ()=>{ state.sellMode = !state.sellMode; state.selectedTower=null; refreshToolbar(); };

  function startWave(){ state.wavesStarted++; const waveNum = state.wavesStarted; const spawner = { waveNum, toSpawn: 10 + Math.floor(waveNum*2.4), cooldown: 20, between: Math.max(14, 44 - waveNum*2) }; state.spawners.push(spawner); updateUI(); showToast(`Wave ${waveNum} started`); }
  function updateUI(){ ui.cash.textContent = `$${state.cash}`; ui.lives.textContent = state.lives; ui.wave.textContent = state.wavesStarted; }
  updateUI();

  // --- Main loop with speed ---
  function step(){ if (state.playing){ for (let i=0;i<state.speed;i++) logic(); } draw(); updateTowerPanel(); requestAnimationFrame(step); }
  requestAnimationFrame(step);

  function logic(){ for (const s of state.spawners){ if (s.cooldown-- <= 0 && s.toSpawn>0){ state.enemies.push(makeEnemyForWave(s.waveNum)); s.toSpawn--; s.cooldown = s.between; } } state.spawners = state.spawners.filter(s=>s.toSpawn>0); for (const e of state.enemies){ moveEnemy(e); } state.enemies = state.enemies.filter(e=>e.alive && e.hp>0); for (const t of state.towers){ const stats = getStats(t); const base = TowerByKey[t.key]; if (base.mode==='aura'){ t.rot = (t.rot||0) + 0.01; for (const e of state.enemies){ const d = Math.hypot(e.x-t.x, e.y-t.y); if (d <= stats.range){ e.slow = Math.max(e.slow, Math.min(0.7, (base.slow||0)+ (stats.slow||0))); e.slowTimer = Math.max(e.slowTimer, 6); } } continue; } if (t.cd>0){ t.cd--; continue; } let target=null, bestProg=-1; for (const e of state.enemies){ const d = Math.hypot(e.x-t.x, e.y-t.y); if (d <= stats.range){ const prog = e.seg + e.t; if (prog>bestProg){ bestProg=prog; target=e; } } } if (!target) continue; t.rot = Math.atan2(target.y - t.y, target.x - t.x); if (base.mode==='projectile'){ spawnProjectile(t, target, stats); t.cd = stats.cd; } else if (base.mode==='beam'){ target.hp -= stats.dmg; addBeam(t.x, t.y, target.x, target.y, base.color, stats.beamWidth||3); t.cd = stats.cd; if (target.hp<=0){ target.alive=false; state.cash += target.type.reward; updateUI(); } } else if (base.mode==='chain'){ let current = target; let remaining = (stats.chain||base.chain||3); let dmg = stats.dmg; const visited = new Set(); let fromX=t.x, fromY=t.y; while (current && remaining>0){ current.hp -= Math.round(dmg); addZapPath(fromX, fromY, current.x, current.y, base.color); visited.add(current); fromX=current.x; fromY=current.y; let next=null, bestD=1e9; for (const e of state.enemies){ if (visited.has(e) || !e.alive) continue; const d = Math.hypot(e.x-current.x, e.y-current.y); if (d<bestD && d<=(stats.chainRange||base.chainRange||110)){ bestD=d; next=e; } } current = next; remaining--; dmg *= 0.7; } t.cd = stats.cd; for (const e of state.enemies){ if (e.hp<=0 && e.alive){ e.alive=false; state.cash += e.type.reward; updateUI(); } } } } for (const p of state.projectiles){ p.x += p.vx; p.y += p.vy; let hit=null, minD=999; for (const e of state.enemies){ const d = Math.hypot(e.x-p.x, e.y-p.y); if (d<12 && d<minD){ minD=d; hit=e; } } if (hit){ hit.hp -= p.dmg; if (p.splash){ for (const e of state.enemies){ const d = Math.hypot(e.x-hit.x, e.y-hit.y); if (d<=p.splash){ e.hp -= Math.floor(p.dmg*0.6); } } } p.alive=false; if (hit.hp<=0){ hit.alive=false; state.cash += hit.type.reward; updateUI(); } } if (p.x< -20 || p.y< -20 || p.x>canvas.clientWidth+20 || p.y>canvas.clientHeight+20) p.alive=false; } state.projectiles = state.projectiles.filter(p=>p.alive); state.beams.forEach(b=>b.ttl--); state.beams = state.beams.filter(b=>b.ttl>0); state.zaps.forEach(z=>z.ttl--); state.zaps = state.zaps.filter(z=>z.ttl>0); if (state.lives<=0){ state.playing=false; state.enemies.length=0; state.projectiles.length=0; state.beams.length=0; state.zaps.length=0; state.spawners.length=0; } }

  function draw(){ const w = canvas.clientWidth, h = canvas.clientHeight; ctx.clearRect(0,0,w,h); ctx.save(); ctx.strokeStyle = '#22306a'; ctx.lineWidth = state.pathWidth*2; ctx.lineCap = 'round'; ctx.globalAlpha = 0.25; ctx.beginPath(); for (let i=0;i<state.path.length;i++){ const p=state.path[i]; if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); } ctx.stroke(); ctx.globalAlpha = 1; ctx.strokeStyle = '#5eead480'; ctx.lineWidth = 4; ctx.setLineDash([14,8]); ctx.beginPath(); for (let i=0;i<state.path.length;i++){ const p=state.path[i]; if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); } ctx.stroke(); ctx.setLineDash([]); const s = state.path[0], e = state.path[state.path.length-1]; if (s){ ctx.fillStyle = COLORS.startHole; ctx.beginPath(); ctx.arc(s.x,s.y, 18, 0, Math.PI*2); ctx.fill(); } if (e){ ctx.fillStyle = COLORS.endHole; ctx.beginPath(); ctx.arc(e.x,e.y, 18, 0, Math.PI*2); ctx.fill(); } ctx.restore(); if (state.building && !state.sellMode){ const base = TowerByKey[state.building]; const stats = base; ctx.save(); ctx.fillStyle = COLORS.range; ctx.strokeStyle = '#1f2b66'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.arc(state.mouse.x, state.mouse.y, stats.range, 0, Math.PI*2); ctx.fill(); ctx.stroke(); drawTower({key: base.key, x: state.mouse.x, y: state.mouse.y, rot: 0, level:1}); ctx.restore(); }
    for(const t of state.towers){ drawTower(t); }
    for(const en of state.enemies){ drawEnemy(en); }
    for(const p of state.projectiles){ ctx.save(); ctx.translate(p.x,p.y); ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur = 8; ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    for (const b of state.beams){ ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = b.color; ctx.lineWidth = b.width || 3; ctx.shadowColor = b.color; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(b.x1,b.y1); ctx.lineTo(b.x2,b.y2); ctx.stroke(); ctx.restore(); }
    for (const z of state.zaps){ ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = z.color; ctx.lineWidth = 2; ctx.shadowColor = z.color; ctx.shadowBlur = 12; ctx.beginPath(); for (let i=0;i<z.pts.length;i++){ const p=z.pts[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke(); ctx.restore(); }
    if (!state.playing && state.lives<=0){ ctx.fillStyle = 'rgba(0,0,0,.6)'; ctx.fillRect(0,0,w,h); ctx.fillStyle = '#fecaca'; ctx.font = 'bold 42px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText('Game Over', w/2, h/2); ctx.font = '16px ui-sans-serif, system-ui'; ctx.fillStyle = '#e5e7eb'; ctx.fillText('Refresh or press Reset', w/2, h/2+28); }
  }

  // --- Tower panel (selection & upgrades) ---
  function updateTowerPanel(){ const p = ui.towerPanel; const t = state.selectedTower; if (!t){ p.classList.add('hidden'); return; } const stats = getStats(t); const base = TowerByKey[t.key]; p.classList.remove('hidden'); p.innerHTML = `
      <h4>${base.name} — Lv.${t.level||1}</h4>
      <div class="row"><span>Damage</span><strong>${stats.dmg||0}</strong></div>
      <div class="row"><span>Range</span><strong>${stats.range}</strong></div>
      <div class="row"><span>Cooldown</span><strong>${stats.cd||0}</strong></div>
      ${base.mode==='aura'?`<div class="row"><span>Slow</span><strong>${Math.round(((base.slow||0)+(stats.slow||0))*100)}%</strong></div>`:''}
      <div class="btns">
        <button id="upgradeBtn">Upgrade ${upgradeLabel(t)}</button>
        <button id="sellBtn">Sell</button>
      </div>
    `; const r= canvas.getBoundingClientRect(); const x = t.x + 16; const y = t.y - 16; p.style.left = (x) + 'px'; p.style.top = (y) + 'px'; document.getElementById('upgradeBtn').onclick = upgradeSelected; document.getElementById('sellBtn').onclick = ()=>{ state.cash += Math.floor((t.cost||0) * 0.7); state.towers = state.towers.filter(z=>z!==t); state.selectedTower=null; updateUI(); showToast('Sold'); };
  }
  function upgradeLabel(t){ const lvl=t.level||1; if (lvl>=3) return '(max)'; const cost = (UPGRADE_COST[t.key]||[])[lvl-1]||'?'; return `$${cost}`; }
  function upgradeSelected(){ const t=state.selectedTower; if(!t) return; const lvl=t.level||1; if (lvl>=3){ showToast('Max level'); return; } const cost=(UPGRADE_COST[t.key]||[])[lvl-1]; if (state.cash<cost){ showToast('Not enough cash', true); return; } state.cash-=cost; t.level= lvl+1; updateUI(); showToast('Upgraded'); }

  function saveGame(){ const data = { v:GAME_VERSION, cash:state.cash, lives:state.lives, wavesStarted:state.wavesStarted, mapIndex:state.mapIndex, towers: state.towers.map(t=>({key:t.key,x:t.x,y:t.y,rot:t.rot||0,level:t.level||1,cost:t.cost||TowerByKey[t.key].cost})) }; try{ localStorage.setItem(SAVE_KEY, JSON.stringify(data)); showToast('Saved'); }catch(e){ showToast('Save failed', true); } }
  function loadGame(){ try{ const txt = localStorage.getItem(SAVE_KEY); if(!txt){ showToast('No save found', true); return; } const d = JSON.parse(txt); resetGame(true); state.cash=d.cash|0; state.lives=d.lives|0; state.wavesStarted=d.wavesStarted|0; state.mapIndex= (d.mapIndex||0)%Maps.length; generatePath(); state.towers = (d.towers||[]).map(o=>({key:o.key,x:o.x,y:o.y,rot:o.rot||0,cd:0,level:o.level||1,cost:o.cost||TowerByKey[o.key].cost})); updateUI(); showToast('Loaded'); }catch(e){ showToast('Load failed', true); } }
  function resetGame(keepMap){ state.enemies.length=0; state.projectiles.length=0; state.beams.length=0; state.zaps.length=0; state.spawners.length=0; state.towers.length=0; state.selectedTower=null; state.wavesStarted=0; state.cash=150; state.lives=20; if(!keepMap){ state.mapIndex=0; generatePath(); } updateUI(); showToast('Reset'); }
})();
  </script>
</body>
</html>
